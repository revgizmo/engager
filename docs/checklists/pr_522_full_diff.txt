diff --git a/tests/testthat/test-ferpa_compliance.R b/tests/testthat/test-ferpa_compliance.R
index 9d3e201..fb9b6d3 100644
--- a/tests/testthat/test-ferpa_compliance.R
+++ b/tests/testthat/test-ferpa_compliance.R
@@ -1,3 +1,22 @@
+test_that("identify_anonymization_columns selects expected PII fields", {
+  data <- tibble::tibble(
+    student_id = c('1', '2'),
+    preferred_name = c('Alice', 'Bob'),
+    email_address = c('a@example.com', 'b@example.com'),
+    notes = c('ok', 'ok'),
+    section = c('A', 'B')
+  )
+
+  columns <- identify_anonymization_columns(data, preserve_columns = 'notes')
+  expect_setequal(columns, c('student_id', 'preferred_name', 'email_address'))
+})
+
+test_that("identify_anonymization_columns returns empty set when no PII detected", {
+  data <- tibble::tibble(section = c('A', 'B'), score = c(10, 20))
+  columns <- identify_anonymization_columns(data, preserve_columns = character())
+  expect_length(columns, 0L)
+})
+
 test_that("validate_ferpa_compliance works correctly", {
   # Test data with PII
   sample_data <- tibble::tibble(
diff --git a/tests/testthat/test-hash_name_consistently.R b/tests/testthat/test-hash_name_consistently.R
new file mode 100644
index 0000000..bf9fc3a
--- /dev/null
+++ b/tests/testthat/test-hash_name_consistently.R
@@ -0,0 +1,33 @@
+test_that("hash_name_consistently normalizes and hashes deterministically", {
+  names <- c("John Smith", "Smith, John", " john   smith ")
+  hashes <- hash_name_consistently(names, salt = "unit-test", normalize_names = TRUE)
+
+  expect_equal(length(hashes), length(names))
+  expect_true(all(nchar(hashes) == 8))
+  expect_equal(length(unique(hashes)), 1)
+})
+
+test_that("hash_name_consistently respects normalization flag", {
+  variants <- c("Professor Jane Doe", "Doe, Jane", "Jane Doe")
+
+  normalized <- hash_name_consistently(variants, salt = "unit-test", normalize_names = TRUE)
+  raw_hashes <- hash_name_consistently(variants, salt = "unit-test", normalize_names = FALSE)
+
+  expect_equal(normalized[1], normalized[2])
+  expect_equal(normalized[1], normalized[3])
+  expect_false(raw_hashes[1] == raw_hashes[2])
+  expect_false(raw_hashes[1] == raw_hashes[3])
+})
+
+test_that("hash_name_consistently validates inputs and handles missing values", {
+  expect_error(hash_name_consistently(123), "names must be a character vector")
+  expect_error(hash_name_consistently("A", salt = c("a", "b")), "salt must be a single character string")
+  expect_error(hash_name_consistently("A", normalize_names = c(TRUE, FALSE)), "normalize_names must be a single logical value")
+
+  names <- c("Alice", NA_character_, " ")
+  hashes <- hash_name_consistently(names, salt = "unit-test", normalize_names = TRUE)
+
+  expect_true(is.na(hashes[2]))
+  expect_true(is.na(hashes[3]))
+  expect_equal(nchar(hashes[1]), 8)
+})
diff --git a/tests/testthat/test-ideal-export.R b/tests/testthat/test-ideal-export.R
index bcd1b57..ab15a7d 100644
--- a/tests/testthat/test-ideal-export.R
+++ b/tests/testthat/test-ideal-export.R
@@ -275,3 +275,47 @@ test_that("Export functions follow package conventions", {
     unlink(temp_file)
   }
 })
+test_that("xprtdltrnscrptssmmry exports CSV summary with privacy", {
+  temp_dir <- withr::local_tempdir()
+  csv_path <- file.path(temp_dir, 'summary.csv')
+
+  warnings <- character()
+  result_path <- withCallingHandlers(
+    xprtdltrnscrptssmmry(test_data, file_path = csv_path, format = 'csv', privacy_level = 'mask'),
+    warning = function(w) {
+      warnings <<- c(warnings, conditionMessage(w))
+      invokeRestart('muffleWarning')
+    }
+  )
+
+  expect_equal(result_path, csv_path)
+  expect_true(file.exists(csv_path))
+
+  summary_df <- utils::read.csv(csv_path, stringsAsFactors = FALSE)
+  expect_true(all(c('total_rows', 'total_columns', 'unique_speakers', 'time_range', 'export_timestamp') %in% names(summary_df)))
+  expect_equal(summary_df$total_rows, nrow(test_data))
+  expect_true(any(grepl('deprecated', warnings)))
+})
+
+test_that("xprtdltrnscrptssmmry supports JSON export", {
+  temp_dir <- withr::local_tempdir()
+  json_path <- file.path(temp_dir, 'summary.json')
+
+  warnings <- character()
+  result_path <- withCallingHandlers(
+    xprtdltrnscrptssmmry(test_data, file_path = json_path, format = 'json', privacy_level = 'mask'),
+    warning = function(w) {
+      warnings <<- c(warnings, conditionMessage(w))
+      invokeRestart('muffleWarning')
+    }
+  )
+
+  expect_equal(result_path, json_path)
+  expect_true(file.exists(json_path))
+
+  json_content <- jsonlite::read_json(json_path)
+  expect_true('summary_data' %in% names(json_content))
+  expect_equal(json_content$summary_data$total_rows, nrow(test_data))
+  expect_true(any(grepl('deprecated', warnings)))
+})
+
diff --git a/tests/testthat/test-ideal_timing_consistency.R b/tests/testthat/test-ideal_timing_consistency.R
new file mode 100644
index 0000000..80a6396
--- /dev/null
+++ b/tests/testthat/test-ideal_timing_consistency.R
@@ -0,0 +1,55 @@
+test_that("vldtdltmngcnsstncy requires transcript data", {
+  warnings <- character()
+
+  expect_error(
+    withCallingHandlers(
+      vldtdltmngcnsstncy(NULL),
+      warning = function(w) {
+        warnings <<- c(warnings, conditionMessage(w))
+        invokeRestart("muffleWarning")
+      }
+    ),
+    "transcript_data cannot be NULL"
+  )
+
+  expect_true(any(grepl("deprecated", warnings)))
+})
+
+test_that("vldtdltmngcnsstncy detects missing timing columns", {
+  data_missing <- tibble::tibble(name = c("Speaker"))
+
+  warnings <- character()
+  result <- withCallingHandlers(
+    vldtdltmngcnsstncy(data_missing),
+    warning = function(w) {
+      warnings <<- c(warnings, conditionMessage(w))
+      invokeRestart("muffleWarning")
+    }
+  )
+
+  expect_equal(result$status, "FAIL")
+  expect_true("missing_timing_columns" %in% names(result$issues))
+  expect_true(any(grepl("deprecated", warnings)))
+})
+
+test_that("vldtdltmngcnsstncy returns pass for consistent timing data", {
+  consistent <- tibble::tibble(
+    name = c("Instructor", "Student", "Instructor"),
+    start = c(0, 60, 120),
+    end = c(30, 90, 150)
+  )
+
+  warnings <- character()
+  result <- withCallingHandlers(
+    vldtdltmngcnsstncy(consistent),
+    warning = function(w) {
+      warnings <<- c(warnings, conditionMessage(w))
+      invokeRestart("muffleWarning")
+    }
+  )
+
+  expect_equal(result$status, "PASS")
+  expect_equal(result$timing_analysis$total_entries, nrow(consistent))
+  expect_equal(result$timing_analysis$avg_entry_duration, mean(consistent$end - consistent$start))
+  expect_true(any(grepl("deprecated", warnings)))
+})
diff --git a/tests/testthat/test-load_session_mapping.R b/tests/testthat/test-load_session_mapping.R
index 29c743b..eadf9b4 100644
--- a/tests/testthat/test-load_session_mapping.R
+++ b/tests/testthat/test-load_session_mapping.R
@@ -1,3 +1,29 @@
+test_that("load_mapping_file reads mapping with required types", {
+  temp_file <- tempfile(fileext = ".csv")
+  on.exit(unlink(temp_file), add = TRUE)
+
+  sample <- tibble::tibble(
+    zoom_recording_id = c("recording1", "recording2"),
+    dept = c("MATH", "CS"),
+    course = c("101", "201"),
+    section = c("A", "B"),
+    session_date = as.Date(c("2024-01-15", "2024-01-16")),
+    session_time = c("09:00", "14:00"),
+    instructor = c("Dr. Smith", "Dr. Jones")
+  )
+  readr::write_csv(sample, temp_file)
+
+  loaded <- load_mapping_file(temp_file)
+  expect_s3_class(loaded, "tbl_df")
+  expect_true(all(names(sample) %in% names(loaded)))
+  expect_s3_class(loaded$session_date, "Date")
+  expect_type(loaded$session_time, "character")
+})
+
+test_that("load_mapping_file errors when file missing", {
+  expect_error(load_mapping_file("does_not_exist.csv"), class = "zse_input_error")
+})
+
 test_that("load_session_mapping loads mapping file correctly", {
   # Create a temporary mapping file
   temp_file <- tempfile(fileext = ".csv")
diff --git a/tests/testthat/test-lookup-merge-utils.R b/tests/testthat/test-lookup-merge-utils.R
index 6c3bffa..4dbe0a0 100644
--- a/tests/testthat/test-lookup-merge-utils.R
+++ b/tests/testthat/test-lookup-merge-utils.R
@@ -1,3 +1,70 @@
+test_that("read_lookup_safely returns normalized frame when file missing", {
+  tmp <- tempfile()
+  warnings <- character()
+  result <- withCallingHandlers(
+    read_lookup_safely(tmp),
+    warning = function(w) {
+      warnings <<- c(warnings, conditionMessage(w))
+      invokeRestart('muffleWarning')
+    }
+  )
+
+  expect_s3_class(result, 'data.frame')
+  expect_equal(nrow(result), 0)
+  expect_true(all(c('transcript_name', 'preferred_name', 'formal_name', 'participant_type', 'student_id', 'notes') %in% names(result)))
+  expect_true(any(grepl('deprecated', warnings)))
+})
+
+test_that("read_lookup_safely normalizes columns for existing file", {
+  tmp <- tempfile(fileext = '.csv')
+  on.exit(unlink(tmp), add = TRUE)
+  utils::write.csv(
+    data.frame(transcript_name = 'Alice', preferred_name = 'Alice', stringsAsFactors = FALSE),
+    tmp,
+    row.names = FALSE
+  )
+
+  warnings <- character()
+  result <- withCallingHandlers(
+    read_lookup_safely(tmp),
+    warning = function(w) {
+      warnings <<- c(warnings, conditionMessage(w))
+      invokeRestart('muffleWarning')
+    }
+  )
+
+  expect_s3_class(result, 'data.frame')
+  expect_equal(result$participant_type, 'unknown')
+  expect_equal(result$student_id, 'INSTRUCTOR')
+  expect_true(any(grepl('deprecated', warnings)))
+})
+
+test_that("write_lookup_transactional normalizes and writes lookup data", {
+  tmp <- tempfile(fileext = '.csv')
+  on.exit(unlink(tmp), add = TRUE)
+  lookup <- data.frame(transcript_name = 'Session 1', participant_type = NA_character_, stringsAsFactors = FALSE)
+
+  warnings <- character()
+  path_written <- withCallingHandlers(
+    write_lookup_transactional(lookup, path = tmp),
+    warning = function(w) {
+      warnings <<- c(warnings, conditionMessage(w))
+      invokeRestart('muffleWarning')
+    }
+  )
+
+  expect_equal(path_written, tmp)
+  expect_true(file.exists(tmp))
+
+  reloaded <- utils::read.csv(tmp, stringsAsFactors = FALSE)
+  expect_true(all(c('transcript_name', 'preferred_name', 'formal_name', 'participant_type', 'student_id', 'notes') %in% names(reloaded)))
+  expect_true(any(grepl('deprecated', warnings)))
+})
+
+test_that("write_lookup_transactional validates path input", {
+  expect_error(write_lookup_transactional(data.frame(), path = c('a', 'b')), 'path must be a single character string')
+})
+
 # Test file for lookup merge utility functions
 # Tests for merge_lookup_preserve and ensure_instructor_rows
 # NOTE: These functions are deprecated - tests focus on deprecation behavior
diff --git a/tests/testthat/test-scope-reduction-exports.R b/tests/testthat/test-scope-reduction-exports.R
new file mode 100644
index 0000000..4a69185
--- /dev/null
+++ b/tests/testthat/test-scope-reduction-exports.R
@@ -0,0 +1,30 @@
+test_that("scope reduction accessors expose expected constants", {
+  expect_type(get_essential_functions(), "character")
+  expect_true(length(get_essential_functions()) >= 1)
+  expect_identical(get_essential_functions(), engager:::ESSENTIAL_FUNCTIONS)
+
+  expect_type(get_deprecated_functions(), "character")
+  expect_identical(get_deprecated_functions(), engager:::DEPRECATED_FUNCTIONS)
+
+  expect_type(get_internal_functions(), "character")
+  expect_identical(get_internal_functions(), engager:::INTERNAL_FUNCTIONS)
+})
+
+test_that("get_scope_reduction_summary reports consistent metrics", {
+  summary <- get_scope_reduction_summary()
+
+  expect_true(all(c(
+    "current_functions", "target_functions", "essential_functions",
+    "deprecated_functions", "internal_functions",
+    "reduction_percentage", "functions_to_remove"
+  ) %in% names(summary)))
+
+  expect_equal(summary$essential_functions, length(get_essential_functions()))
+  expect_equal(summary$deprecated_functions, length(get_deprecated_functions()))
+  expect_equal(summary$internal_functions, length(get_internal_functions()))
+
+  expected_reduction <- round((summary$current_functions - summary$target_functions) /
+    summary$current_functions * 100, 1)
+  expect_equal(summary$reduction_percentage, expected_reduction)
+  expect_equal(summary$functions_to_remove, summary$current_functions - summary$target_functions)
+})
diff --git a/tests/testthat/test-success-metrics-verbose.R b/tests/testthat/test-success-metrics-verbose.R
index 8aca78e..5ac356a 100644
--- a/tests/testthat/test-success-metrics-verbose.R
+++ b/tests/testthat/test-success-metrics-verbose.R
@@ -95,3 +95,47 @@ test_that("success metrics respect quiet mode", {
   # Should be able to get target state without errors
   expect_error(get_target_state(), NA)
 })
+
+test_that("track_success_metrics returns structured report with progress", {
+  skip_on_cran()
+
+  captured_warnings <- character()
+  report <- withCallingHandlers(
+    track_success_metrics(),
+    warning = function(w) {
+      captured_warnings <<- c(captured_warnings, conditionMessage(w))
+      invokeRestart("muffleWarning")
+    }
+  )
+
+  expect_true(any(grepl("deprecated", captured_warnings)))
+
+  expect_true(is.list(report))
+  expect_true(all(c("timestamp", "framework", "baseline", "targets", "progress", "summary") %in% names(report)))
+  expect_s3_class(report$timestamp, "POSIXct")
+
+  baseline <- report$baseline
+  expect_true(is.list(baseline))
+  expect_true(all(c("functions", "documentation_files", "test_coverage", "open_issues", "timestamp") %in% names(baseline)))
+
+  expected_functions <- length(list.files("R/", pattern = "\\\.R$", full.names = FALSE))
+  expect_equal(baseline$functions, expected_functions)
+
+  expected_docs <- length(list.files("docs/", recursive = TRUE))
+  expect_equal(baseline$documentation_files, expected_docs)
+
+  expect_true(is.numeric(baseline$test_coverage) || is.na(baseline$test_coverage))
+
+  expect_true(is.list(report$progress))
+  expect_true(all(c("function_scope_ok", "test_coverage_ok", "documentation_ok") %in% names(report$summary)))
+
+  if (!is.null(report$progress$functions)) {
+    expect_equal(report$progress$functions$metric, "functions")
+    expect_equal(report$progress$functions$current, baseline$functions)
+  }
+
+  if (!is.null(report$progress$documentation)) {
+    expect_equal(report$progress$documentation$metric, "documentation")
+    expect_equal(report$progress$documentation$current, baseline$documentation_files)
+  }
+})
